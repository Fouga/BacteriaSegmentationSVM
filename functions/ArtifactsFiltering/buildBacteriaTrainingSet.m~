function         buildBacteriaTrainingSet(sourceD,frame,optical,segmentation_dir,trainingSave_dir, varargin)


if nargin > 3
    thresh = varargin{1};
    thresh_red = thresh(1);
    thresh_green = thresh(1);
    thresh_blue = thresh(1);
else
    thresh_red = 2000;
    thresh_green = 1600;
    thresh_blue = 800;
end


% save patches
save_dir = fullfile(trainingSave_dir);
if ~exist(save_dir)
    mkdir(save_dir)
end
% convnet parameters
shift =10; % number of pixels cut from an image around an object
siz = [224 224]; % size for the final cropped image. It should fit the network requirements 

if frame < 10
  counter = strcat('00',int2str(frame)); 
elseif frame < 100 
  counter = strcat('0',int2str(frame));   
else
  counter = int2str(frame);   
end
prefix = 'section_';
name = strcat(prefix, counter);
% load a mask after svm segmentation 
mask_name = fullfile(segmentation_dir, name, '_0', int2str(optical) ,'.pbm');
BW = imread(mask_name);

if sum(BW(:))>0
    ext = '.tif';
    green = imread(fullfile(sourceD, '2', name, '_0',  int2str(optical), ext));
    red = imread(fullfile(sourceD, '1', name, '_0',  int2str(optical), ext));
    blue = imread(fullfile(sourceD, '3', name, '_0',  int2str(optical), ext));
    rgbIm =  cat(3, green,red,blue);
    cc = bwconncomp(BW,8);
    s = regionprops(cc,'basic');
    centroids = cat(1, s.Centroid);
    rect = round(cat(1,s.BoundingBox));
    PixelList = cat(1,cc.PixelIdxList);
    for i =1:size(centroids,1)
        rect2 = rect(i,:);
                        
        if shift > rect2(1) || shift > rect2(2) || rect2(1)+shift>size(im,2) || rect2(2)+shift>size(im,1)
            shift = 0;
            Im = imcrop(im,[rect2(1)-shift/2 rect2(2)-shift/2 rect2(3)+shift rect2(4)+shift]);
            IM = imcrop(rgbIm,[rect2(1)-shift/2 rect2(2)-shift/2 rect2(3)+shift rect2(4)+shift]);
        else
            Im = imcrop(im,[rect2(1)-shift/2 rect2(2)-shift/2 rect2(3)+shift rect2(4)+shift]);
            IM = imcrop(rgbIm,[rect2(1)-shift/2 rect2(2)-shift/2 rect2(3)+shift rect2(4)+shift]);
        end
